# OS-Lab

这是原神（OS）实验从 Project 2 开始的仓库！

#### 当前项目

Project 4。

#### 最新更改

[2023-11-17] 使用“位图”管理页框和页表，但释放函数尚未测试。

#### 可做的优化



#### [2023-11-13]

  初始化 Project 4 的仓库。

  调整了部分代码的格式；修复了因`allocKernelPage()`等函数失效而导致的`malloc-g.c`编译错误，但该文件中的存储管理函数将在本实验中废除。

  调整了两个 CPU 的内核栈，暂定为`0xffffffc051000000`（0 号 CPU）、`0xffffffc050f00000`。在`head.S`以及`sched.c`中均有定义。

#### [2023-11-13]

  初步写了用虚存启动内核，但存在 Bug 导致内核没有启动。

#### [2023-11-14]

  终于用虚存启动了内核，并且在启动用户程序之前进行了制动（因为尚未实现用户程序的虚存机制）。存在较大的改变：BootLoader 在加载内核时不再一次完成了，而是需要每次 64 个扇区（32 KiB）分步加载。此外，发现一个问题，在`revoke_temp_mapping()`被调用后，即在`boot.c`中对`0x50000000~0x51000000`的临时相等映射被取消后，使用字符串的物理地址调用 BIOS 的`port_write()`会导致错误，修改为内核虚地址后问题解决，推测在 BIOS 中它仍然会使用内核的页表，取消临时映射后就引发了 page fault。此外，用`DEBUG=0`（带 -O2）编译似乎也不会出问题。

#### [2023-11-15]

  为使用虚存启进程做准备，初步填补了`alloc_page_helper()`函数。

  修复了`pg_base`符号冲突问题，并且进行了上板测试，能够用虚存启动内核并制动。

  修改了 createimage 工具以及 GlucOS 中对用户程序的定义`task_info_t`，新增`m_size`成员用于记录该程序在主存中的总大小。

  修改了`create_proc()`、`load_task_img()`、`init_pcb_stack()`等函数使其支持虚存，**但未经过任何测试**；修改了`kmalloc_g()`函数的分配缓冲区为内核 .bss 段的 4 MiB 空间；取消对`umalloc_g()`的支持，但背上了 Project 2 多线程的历史包袱（make 编译时需带上`MTHREAD=0`）；目前，在 QEMU 上内核仍然可以用虚存来启动。

  抛弃了 Project 2 的多线程留下的历史包袱，目前 -O2 上板能启动内核。

  设置`sstatus`的 SUM 为 1，并且增加了注释。

  解除了 CPU 的制动，成功用虚存机制启动用户程序（glush 与 fly）并实现命令行参数传递！-O2 编译下上板正常。但存在严重缺陷，就是给用户程序分配的物理页框以及页表在终止之后不能回收。

  优化了`kmalloc_g()`使用的 4 MiB 的 `kallocbuf`在 .bss 段导致内核启动时清空 .bss 耗时长的问题。

  开始动手修改物理页框管理函数`alloc_page()`，正在准备用类似”位图“的”char map“方法实现物理页框的分配与释放。接下来还要做`free_page()`函数，以及对页表所用页框的类似管理，以及当进程终止时回收其页表和物理页框……目前 -O2 上板正常。

#### [2023-11-17]

  使用“位图”（Char map）方法管理物理页框和页表，但还没有测试过回收`free_page/pagetable()`。目前 -O2 上板正常。下一步：进程终止时回收其页表和页框。

  优化了`SAVE_CONTEXT`与`RESTORE_CONTEXT`，详见`entry.S`中的注释，使之更严谨，以便为后面可能需要的嵌套异常（S 态下的 page fault）做准备。目前 -O2 上板正常。



