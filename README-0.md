# OS-Lab

这是原神（OS）实验从 Project 2 开始的仓库！

#### 当前项目

Project 4。

#### 最新更改

  新增页交换函数功能，但未经测试。

#### 可做的优化



#### [2023-11-13]

  初始化 Project 4 的仓库。

  调整了部分代码的格式；修复了因`allocKernelPage()`等函数失效而导致的`malloc-g.c`编译错误，但该文件中的存储管理函数将在本实验中废除。

  调整了两个 CPU 的内核栈，暂定为`0xffffffc051000000`（0 号 CPU）、`0xffffffc050f00000`。在`head.S`以及`sched.c`中均有定义。

#### [2023-11-13]

  初步写了用虚存启动内核，但存在 Bug 导致内核没有启动。

#### [2023-11-14]

  终于用虚存启动了内核，并且在启动用户程序之前进行了制动（因为尚未实现用户程序的虚存机制）。存在较大的改变：BootLoader 在加载内核时不再一次完成了，而是需要每次 64 个扇区（32 KiB）分步加载。此外，发现一个问题，在`revoke_temp_mapping()`被调用后，即在`boot.c`中对`0x50000000~0x51000000`的临时相等映射被取消后，使用字符串的物理地址调用 BIOS 的`port_write()`会导致错误，修改为内核虚地址后问题解决，推测在 BIOS 中它仍然会使用内核的页表，取消临时映射后就引发了 page fault。此外，用`DEBUG=0`（带 -O2）编译似乎也不会出问题。

#### [2023-11-15]

  为使用虚存启进程做准备，初步填补了`alloc_page_helper()`函数。

  修复了`pg_base`符号冲突问题，并且进行了上板测试，能够用虚存启动内核并制动。

  修改了 createimage 工具以及 GlucOS 中对用户程序的定义`task_info_t`，新增`m_size`成员用于记录该程序在主存中的总大小。

  修改了`create_proc()`、`load_task_img()`、`init_pcb_stack()`等函数使其支持虚存，**但未经过任何测试**；修改了`kmalloc_g()`函数的分配缓冲区为内核 .bss 段的 4 MiB 空间；取消对`umalloc_g()`的支持，但背上了 Project 2 多线程的历史包袱（make 编译时需带上`MTHREAD=0`）；目前，在 QEMU 上内核仍然可以用虚存来启动。

  抛弃了 Project 2 的多线程留下的历史包袱，目前 -O2 上板能启动内核。

  设置`sstatus`的 SUM 为 1，并且增加了注释。

  解除了 CPU 的制动，成功用虚存机制启动用户程序（glush 与 fly）并实现命令行参数传递！-O2 编译下上板正常。但存在严重缺陷，就是给用户程序分配的物理页框以及页表在终止之后不能回收。

  优化了`kmalloc_g()`使用的 4 MiB 的 `kallocbuf`在 .bss 段导致内核启动时清空 .bss 耗时长的问题。

  开始动手修改物理页框管理函数`alloc_page()`，正在准备用类似”位图“的”char map“方法实现物理页框的分配与释放。接下来还要做`free_page()`函数，以及对页表所用页框的类似管理，以及当进程终止时回收其页表和物理页框……目前 -O2 上板正常。

#### [2023-11-17]

  使用“位图”（Char map）方法管理物理页框和页表，但还没有测试过回收`free_page/pagetable()`。目前 -O2 上板正常。下一步：进程终止时回收其页表和页框。

  优化了`SAVE_CONTEXT`与`RESTORE_CONTEXT`，详见`entry.S`中的注释，使之更严谨，以便为后面可能需要的嵌套异常（S 态下的 page fault）做准备。目前 -O2 上板正常。

#### [2023-11-18]

  将 PCB 的`user_stack`改为数组以支持分配多个（通过宏`USTACK_NPG`指定）页面给用户栈，其每个元素是每个物理页框的内核虚地址。新增临时的`handle_pagefault()`，遇到 Page fault 时就终止进程。并且通过了 GlucOStest 的测试。

  实现释放进程页框和页表的函数`free_pages_of_proc()`并且用 GDB 观测正常，-O2 在 QEMU 上运行正常，尚未上板验证。至此 Task 1 算是勉强完成（除了上板）。

  -O2 编译下上板发现有些问题，在启用 GlucOStest 时有概率触发非法指令异常（`0x2`）或取指缺页异常（`0xc`），待修复……

  Bug 复现方法：`exec glush 0 9`，然后`kill 3`，再`exec GlucOStest`。后来发现不用 -O2 也会出错。推测可能跟 TLB 有关系，在终止某个进程之后可能需要刷 TLB。

  进一步细化问题：终止某进程后，再启动别的程序，就会出问题。

  将`do_kill()`中对`free_pages_of_proc()`的调用取消后，就不会出错，推测又触发了 P1-T5 留下的问题：对物理地址`0x52000000`后的某段区域重复写入指令序列会导致错误。

  尝试将`alloc_page()`使用的区域换成物理地址`0x50330000`，仍然不行，看来与位置没有关系。

  终于修好了这个历史遗留问题！原因竟然是……指令 Cache 未同步。

#### [2023-11-20]

  在`do_mbox_recv()`中对传入的地址做了检查，确保其来自用户地址空间，以修复恶意程序传入内核地址导致数据改写的漏洞。新增函数`va2pte()`，根据虚地址和页目录查找页表并返回页表项的内核虚地址，此时`va2kva()`函数改用它实现了。注意，原来的`va2kva()`存在错误，对于 L2 级页表就查到叶节点的情况，返回的地址不正确，忘记了将 PTE 中的物理地址转换为内核虚地址。目前 QEMU 上运行正常。

  初步实现用户栈的缺页处理和按需调页，以及访问地址非法时终止进程。目前 QEMU 上运行正常。下一步：`sys_sbrk()`和数据段的按需调页。

  -O2 上板正常，但发现还有些异常未能添加相应的处理函数，例如非法指令、取指缺页等，一个简单可行的方法是在`handle_other()`中做检查，若未知异常来自用户态则打印一些信息后终止进程。

#### [2023-11-23]

  新增：在`handle_other()`中，当用户程序触发未知异常时，终止进程；`do_sbrk()`函数以及相应的系统调用`sys_sbrk()`。

 使用 gdb 查看 BBL 的指令序列为：

```assembly
(gdb) x/20i 0x50000000
   0x50000000:	csrr	a0,mhartid
   0x50000004:	mv	tp,a0
   0x50000006:	mv	s1,a1
   0x50000008:	auipc	t0,0x58
   0x5000000c:	ld	t0,-1320(t0)
   0x50000010:	csrw	mtvec,t0
   0x50000014:	csrw	mie,zero
  ...
```

  `mtvec`被置为了 `0x50000a30`。

  用 GlucOStest 以及修改的 rw-g 测试了新功能，但在 QEMU 上不能将 U-mode 的异常代理到 S-mode。

  在 make 时用`CFOTHER`可自定义编译选项，加`CFOTHER=-DUSEG_MAX=...`可定义用户程序的 Segment 的允许最大值，将其设为`0x80000000UL`可允许用户使用`sbrk()`分配 1 GiB 以上的空间，但默认是 4 MiB。

  新增数组`pg_uva[]`，用于保存每个物理页框所对的用户虚地址。这样，根据 PID 和虚地址，就能很容易地用`uv2pte()`找到对应的页表项。

  新增文件`mm-swap.c`以及部分相关函数，准备进行与磁盘交换。接下来需要做`swap_from_disk()`，以及在进程结束释放页框的函数`free_pages_of_proc()`中释放其在磁盘中的页。目前 -O2 上板正常。

  新增了完成页交换所需的函数，但**未经触发交换的测试**。且目前默认新 PTE 的 A、D 均为 1，今后可根据需要在某些情况下不要在一分配时就将 A 置 1。目前 -O2 上板正常，下一步进行交换测试。

  修复了一个小 Bug：用户程序在陷入内核后又触发中断，此时不要对内核上锁，返回时也不要解锁。在 QEMU 上测试通过。但在尝试把`entry.S`中读取`current_running[CPU#]`到`$t0`的代码换成宏时出了错误，等待研究是哪一部分的替换导致的。

