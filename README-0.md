# OS-Lab

这是原神（OS）实验从 Project 2 开始的仓库！

#### 当前项目

Project 4。

#### 最新更改

[2023-11-18] 初步实现页框和页表的释放。

#### 可做的优化

  可能存在的漏洞：对于需要传缓冲区指针的系统调用，检查指针是否是用户地址空间，否则要报错以避免修改内核。

#### [2023-11-13]

  初始化 Project 4 的仓库。

  调整了部分代码的格式；修复了因`allocKernelPage()`等函数失效而导致的`malloc-g.c`编译错误，但该文件中的存储管理函数将在本实验中废除。

  调整了两个 CPU 的内核栈，暂定为`0xffffffc051000000`（0 号 CPU）、`0xffffffc050f00000`。在`head.S`以及`sched.c`中均有定义。

#### [2023-11-13]

  初步写了用虚存启动内核，但存在 Bug 导致内核没有启动。

#### [2023-11-14]

  终于用虚存启动了内核，并且在启动用户程序之前进行了制动（因为尚未实现用户程序的虚存机制）。存在较大的改变：BootLoader 在加载内核时不再一次完成了，而是需要每次 64 个扇区（32 KiB）分步加载。此外，发现一个问题，在`revoke_temp_mapping()`被调用后，即在`boot.c`中对`0x50000000~0x51000000`的临时相等映射被取消后，使用字符串的物理地址调用 BIOS 的`port_write()`会导致错误，修改为内核虚地址后问题解决，推测在 BIOS 中它仍然会使用内核的页表，取消临时映射后就引发了 page fault。此外，用`DEBUG=0`（带 -O2）编译似乎也不会出问题。

#### [2023-11-15]

  为使用虚存启进程做准备，初步填补了`alloc_page_helper()`函数。

  修复了`pg_base`符号冲突问题，并且进行了上板测试，能够用虚存启动内核并制动。

  修改了 createimage 工具以及 GlucOS 中对用户程序的定义`task_info_t`，新增`m_size`成员用于记录该程序在主存中的总大小。

  修改了`create_proc()`、`load_task_img()`、`init_pcb_stack()`等函数使其支持虚存，**但未经过任何测试**；修改了`kmalloc_g()`函数的分配缓冲区为内核 .bss 段的 4 MiB 空间；取消对`umalloc_g()`的支持，但背上了 Project 2 多线程的历史包袱（make 编译时需带上`MTHREAD=0`）；目前，在 QEMU 上内核仍然可以用虚存来启动。

  抛弃了 Project 2 的多线程留下的历史包袱，目前 -O2 上板能启动内核。

  设置`sstatus`的 SUM 为 1，并且增加了注释。

  解除了 CPU 的制动，成功用虚存机制启动用户程序（glush 与 fly）并实现命令行参数传递！-O2 编译下上板正常。但存在严重缺陷，就是给用户程序分配的物理页框以及页表在终止之后不能回收。

  优化了`kmalloc_g()`使用的 4 MiB 的 `kallocbuf`在 .bss 段导致内核启动时清空 .bss 耗时长的问题。

  开始动手修改物理页框管理函数`alloc_page()`，正在准备用类似”位图“的”char map“方法实现物理页框的分配与释放。接下来还要做`free_page()`函数，以及对页表所用页框的类似管理，以及当进程终止时回收其页表和物理页框……目前 -O2 上板正常。

#### [2023-11-17]

  使用“位图”（Char map）方法管理物理页框和页表，但还没有测试过回收`free_page/pagetable()`。目前 -O2 上板正常。下一步：进程终止时回收其页表和页框。

  优化了`SAVE_CONTEXT`与`RESTORE_CONTEXT`，详见`entry.S`中的注释，使之更严谨，以便为后面可能需要的嵌套异常（S 态下的 page fault）做准备。目前 -O2 上板正常。

#### [2023-11-18]

  将 PCB 的`user_stack`改为数组以支持分配多个（通过宏`USTACK_NPG`指定）页面给用户栈，其每个元素是每个物理页框的内核虚地址。新增临时的`handle_pagefault()`，遇到 Page fault 时就终止进程。并且通过了 GlucOStest 的测试。

  实现释放进程页框和页表的函数`free_pages_of_proc()`并且用 GDB 观测正常，-O2 在 QEMU 上运行正常，尚未上板验证。至此 Task 1 算是勉强完成（除了上板）。

  -O2 编译下上板发现有些问题，在启用 GlucOStest 时有概率触发非法指令异常（`0x2`）或取指缺页异常（`0xc`），待修复……

  Bug 复现方法：`exec glush 0 9`，然后`kill 3`，再`exec GlucOStest`。后来发现不用 -O2 也会出错。推测可能跟 TLB 有关系，在终止某个进程之后可能需要刷 TLB。

  进一步细化问题：终止某进程后，再启动别的程序，就会出问题。

  将`do_kill()`中对`free_pages_of_proc()`的调用取消后，就不会出错，推测又触发了 P1-T5 留下的问题：对物理地址`0x52000000`后的某段区域重复写入指令序列会导致错误。

  尝试将`alloc_page()`使用的区域换成物理地址`0x50330000`，仍然不行，看来与位置没有关系。

  终于修好了这个历史遗留问题！原因竟然是……指令 Cache 未同步。

#### [2023-11-20]

  在`do_mbox_recv()`中对传入的地址做了检查，确保其来自用户地址空间，以修复恶意程序传入内核地址导致数据改写的漏洞。新增函数`va2pte()`，根据虚地址和页目录查找页表并返回页表项的内核虚地址，此时`va2kva()`函数改用它实现了。注意，原来的`va2kva()`存在错误，对于 L2 级页表就查到叶节点的情况，返回的地址不正确，忘记了将 PTE 中的物理地址转换为内核虚地址。目前 QEMU 上运行正常。

初步实现用户栈的缺页处理和按需调页，以及访问地址非法时终止进程。目前 QEMU 上运行正常。下一步：`sys_sbrk()`和数据段的按需调页。