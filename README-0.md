# OS-Lab

这是原神（OS）实验从 Project 2 开始的仓库！

#### 当前项目

Project 5。

#### 最新更改



#### 可做的优化

  在 glush 查询键盘输入时，如果一段时间得不到输入，可以考虑降低查询频率（例如每数秒才查询一次）以降低功耗。

  在`do_kill()`中增加判断，如果 glush 被终止了，自动重新起一个 glush。

#### [2023-12-01]

  初始化 Project 5 的仓库。

  目前编译不会有错误（会有未使用变量的警告），内核能启动但是会触发内核缺页的 panic，估计是因为没有给 IO 设备映射地址空间。

#### [2023-12-05]

  原神，启动！初步完成了 IOremap 和 E1000 的发送初始化函数`e1000_configure_tx()`。目前系统在 QEMU 上可以启动（`make run-net`）。

#### [2023-12-06]

  原神，启……启动……

  简化了`do_sleep()`函数，直接调用`do_block()`。

  初步实现使用测试程序 send 发送数据包，但一次只发送 4 个，未尝试多个的情况。

  新增大量发送程序 send2，可通过命令行参数指定发送重复次数。但目前未触发缓冲区满导致阻塞的情况，尚待测试。除此以外 -O2 上板正常，可通过 Windows 上的 Wireshark 接收数据包。

  通过修改代码强制触发了缓冲区满导致阻塞的情况，QEMU 和上板测试大概是没问题。不过**现在对阻塞的处理仍然是临时的**，在`do_scheduler()`时将阻塞的进程唤醒，待实现网卡中断后可得到优化。

#### [2023-12-07]

  新增了网卡接收的 `do_net_recv()` 系统调用和 `e1000_poll()` 函数实现，目前编译没问题但未经测试接收功能。

#### [2023-12-08]

  修复了网卡接收的一些问题，在系统启动时向屏幕和日志中输出编译日期和时间，并且支持用户按任意键保持屏幕上的信息。

  新增测试程序 recv2，可通过命令行参数配置接收数据包数（`-n`）、打印长度限制（`-l`）以及打印格式（`-c`代表以字符打印，否则十六进制格式）。例如：`exec recv2 -n32 -l80 -c &`。

  修改了`e1000_poll()`函数，废除了无用的`rcq_head`指针，接收时直接从`rcq_tail`所指的的下一个位置开始。目前 -O2 上板正常，可以接收数量超过接收描述符队列长度的数据包。

  发现 Bug：在 recv2 接收数据过程中，glush 执行`ps`可能会报出 Segment fault，地址是`0x1e00350a20`！

  上述 Bug 只会出现在 -O2 情况下！大概是在内核态触发了缺页……

  肉眼瞪出了这个 Bug，是`rx_frm_buffer[]`误写成了`tx_frm_buffer[]`……

#### [2023-12-09]

  新增 TXQE 和 RXDMT0 网卡中断的支持，TXQE 尚未测试，但 RXDMT0 存在问题，有时候 recv2 不能唤醒。在板卡上当 recv2 请求 72 个包，外部程序第一次发 36 个时会触发中断，但再发 36 个时没有触发中断。此外，触发中断时在日志中观察到了 PLIC claim 为 0 的未知中断。等待修复……

  查出来了原因，是在`handle_irq_ext()`中对 E1000 的`ICR`判断逻辑有问题，没能支持一次处理多种中断，而是强加了优先级。

  新增系统调用`do_net_send_array()`以及发送函数`e1000_transmit_array()`用于一口气发送多个数据包，以及相应的测试程序 send3，但仍未触发发送阻塞和 TXQE 中断。

  调整系统参数，发送队列（`TXDESCS`）多达 2048，每次发 2047 个长度为 700 多字节的包，连发两次，终于触发了发送阻塞和 TXQE 中断（已截屏保存）……